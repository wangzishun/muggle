# diff 算法

- 思路是只对同级元素进行 Diff；两个不同类型的节点不能复用；通过 key 来保持节点的稳定。react 分别针对多节点和单节点进行 diff， diff 的对象是通过新生成的 ReactElement 数组和 上一次 commit 后的 current fiber 的子节点链表。无论是单节点还是多节点的比较, 都是为了生成子节点，并且(新增, 删除, 移动位置等)打上标记, 等待 commit 阶段再处理.

- 多节点对比的场景中主要有两次循环 reconcileChildFibers/reconcileChildrenIterator。
  O(n^3) 的大致由来： 两棵树嵌套循环寻找不同的节点：O(n^2)，寻找到不同的节点后，需要再遍历得到最小的转换消耗，最终得 到 O(n^3)

  1.  第一次循环: 遍历最长公共序列(key 相同), 公共序列的节点都视为可复用。
  2.  如果新的 element 节点都被遍历完, 那么 oldFiber 中剩余节点都要标记删除
  3.  但如果 oldFiber 节点被遍历完, 那么新的 element 节点都要标记新增
  4.  然后进行第二次循环，先将剩余的 oldFiber 转成 map 结构，然后遍历新的 element 节点，如果新的 element 节点的 key 在 map 中存在，那么就将这个节点标记为可复用，否则就标记为新增。最后将 map 中没用到的 fiber 标记为删除。

  我在学习源码的时候有一个小插曲，第一次循环的里面有一个 index 的比较，如果 oldFiber.index > newIdx 就会直接跳出这次循环，一开始我不知道他是干什么的，debug 了很多次也进不了这个判断分支。后来查 issure 发现这个判断是应对 falsy 元素的，就是 null、false 这种。因为 falsy 元素在数组中破坏了原来的顺序，导致按顺序比较 key 的最长公共序列的时候没有意义，所以直接跳出是合理的。

  还有一个比较有意思的点是通过 lastPlacedIndex 和新 index 进行对比得出是否发生移动 lastPlacedIndex = placeChild(newFiber, lastPlacedIndex, newIdx);

- 单节点 reconcileSingleElement

  在单节点的场景里，会先判断 key 是否相同，再判断 type 是否相同，只有都相同时才能复用。如果一个 fiber 有子节点当 child !== null 且 key 相同但是 type 不同时，会把这个节点和他之后的兄弟节点都标记删除，如果 key 不同那么就只会把这个节点标记删除。其他情况就是创建新的 fiber 并返回。

# key 的作用

作为每一个虚拟节点的唯一 ID, 可以依靠 key 更快更准的拿到旧节点中可复用的那个节点.

1. 用 key:

   - 维持组件的状态, 保证组件的复用
   - diff 算法的过程中需要去查找能够复用的节点, 有 key 的时候, 通过 map 进行可复用节点的查找, 提升查找性能.
   - 节点复用带来的性能提升, 降低创建/删除节点的操作

2. 不用 key：
   - 就地复用节点. 只会在节点的属性层面上进行比较和更新. 所以可能在某种程度上会有渲染性能上的提升
   - 无法维持组件的状态. 过渡动画效果、表单状态

在实际的应用场景里, 我的理解是只有在重新排序的场景下才有优化的可能. 在一般的简单列表的渲染场景下, 不加 key 反而能达到 dom 节点就地复用的效果, 只需要修改 DOM 文本内容而不是移除/添加节点, 某种程度上会有渲染性能的提升. 如果无脑加 key 的话, 某些场景下, 如果每次更新都不能找到可复用节点, 那么就需要在 DOM 里添加/移除节点.

当然这都是我的经验之谈, 总的来说, 在数据稳定的时候, 节点可以复用, 加 key 能提高性能; 对于频繁更新的数据, 节点不能复用, 这个时候不加 key 能够达到 dom 就地复用的效果, 但可能产生一些问题, 无法维持组件的状态, 产生问题的场景下需要带上 key.

性能提升有多方面的影响, diff 算法的效率, DOM 节点增删移动的次数, 数据的量级, 都会影响最终的结果.
