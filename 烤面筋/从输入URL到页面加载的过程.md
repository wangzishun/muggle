- [主干流程](#主干流程)
- [从浏览器接收 url 到开启网络请求线程](#从浏览器接收-url-到开启网络请求线程)
- [解析 URL](#解析-url)
- [DNS 查询得到 IP](#dns-查询得到-ip)
- [tcp/ip 请求](#tcpip-请求)
- [从服务器接收到请求到对应后台接收到请求](#从服务器接收到请求到对应后台接收到请求)
- [后台和前台的 http 交互](#后台和前台的-http-交互)
- [http 的缓存： 强缓存与弱缓存](#http-的缓存-强缓存与弱缓存)
- [解析页面流程](#解析页面流程)
- [简单层与复合层](#简单层与复合层)
- [loaded 和 domcontentloaded](#loaded-和-domcontentloaded)

# 主干流程

1. 从浏览器接收 url 到开启网络请求线程（这一部分可以展开浏览器的机制以及进程与线程之间的关系）
2. 开启网络线程到发出一个完整的 http 请求（这一部分涉及到 dns 查询，tcp/ip 请求，五层因特网协议栈等知识）
3. 从服务器接收到请求到对应后台接收到请求（这一部分可能涉及到负载均衡，安全拦截以及后台内部的处理等等）
4. 后台和前台的 http 交互（这一部分包括 http 头部、响应码、报文结构、cookie 等知识，可以提下静态资源的 cookie 优化，以及编码解码，如 gzip 压缩等）
5. 单独拎出来的缓存问题，http 的缓存（这部分包括 http 缓存头部，etag，catch-control 等）
6. 浏览器接收到 http 数据包后的解析流程（解析 html-词法分析然后解析成 dom 树、解析 css 生成 css 规则树、合并成 render 树，然后 layout、painting 渲染、复合图层的合成、GPU 绘制、外链资源的处理、loaded 和 domcontentloaded 等）
7. CSS 的可视化格式模型（元素的渲染规则，如包含块，控制框，BFC，IFC 等概念）
8. JS 引擎解析过程（JS 的解释阶段，预处理阶段，执行阶段生成执行上下文，VO，作用域链、回收机制等等）
9. 其它（可以拓展不同的知识模块，如跨域，web 安全，hybrid 模式等等内容）

1

1. 首先浏览器进程的 UI 线程会进行处理：如果是 URI，则会发起网络请求来获取网站内容；如果不是，则进入搜索引擎。
2. 如果需要发起网络请求，请求过程由网络线程来完成。HTTP 请求响应如果是 HTML 文件，则将数据传递到渲染器进程；如果是其他文件则意味着这是下载请求，此时会将数据传递到下载管理器。
3. 如果请求响应为 HTML 内容，此时浏览器应导航到请求站点，网络线程便通知 UI 线程数据准备就绪。
4. 接下来，UI 线程会寻找一个渲染器进程来进行网页渲染。当数据和渲染器进程都准备好后，HTML 数据通过 IPC 从浏览器进程传递到渲染器进程中。
5. 渲染器进程接收 HTML 数据后，将开始加载资源并渲染页面。
6. 渲染器进程完成渲染后，通过 IPC 通知浏览器进程页面已加载。

# 从浏览器接收 url 到开启网络请求线程

浏览器是多进程的，有一个主控进程，以及每一个 tab 页面都会新开一个进程（某些情况下多个 tab 会合并进程）。进程可能包括主控进程，插件进程，GPU，tab 页（浏览器内核）等等

每一个 tab 页面可以看作是浏览器内核进程，然后这个进程是多线程的，它有几大类子线程：GUI 线程、JS 引擎线程、事件触发线程、定时器线程、网络请求线程

# 解析 URL

输入 URL 后，会进行解析，解析成一个个的组成部分，如协议、域名、端口、路径、参数、锚点等等

每次网络请求时都需要开辟单独的线程进行，譬如如果 URL 解析到 http 协议，就会新建一个网络线程去处理资源下载。浏览器会根据解析出得协议，开辟一个网络线程，前往请求资源。

# DNS 查询得到 IP

如果浏览器有缓存，直接使用浏览器缓存，否则使用本机缓存，再没有的话就是用 host
如果本地没有，就向 dns 域名服务器查询（当然，中间可能还会经过路由，也有缓存等），查询到对应的 IP

dns 解析是很耗时的，因此如果解析域名过多，会让首屏加载变得过慢，可以考虑 dns-prefetch 优化

# tcp/ip 请求

三次握手建立连接，https 还会额外进行 ssl/tls 握手，四次挥手断开连接

五层因特网协议栈，从应用层的发送 http 请求，到传输层通过三次握手建立 tcp/ip 连接，再到网络层的 ip 寻址，再到数据链路层的封装成帧，最后到物理层的利用物理介质传输。

1. 应用层(dns,http) DNS 解析成 IP 并发送 http 请求
2. 传输层(tcp,udp) 建立 tcp 连接（三次握手）
3. 网络层(IP,ARP) IP 寻址
4. 数据链路层(PPP) 封装成帧
5. 物理层(利用物理介质传输比特流)

# 从服务器接收到请求到对应后台接收到请求

负载均衡：调度服务器（反向代理服务器，安装了 nginx 控制负载均衡），然后调度服务器根据实际的调度配置，分配不同的请求给对应集群中的服务器执行，然后调度器等待实际服务器响应，并将它反馈给用户

# 后台和前台的 http 交互

Request Url: 请求的 web 服务器地址
Request Method: 请求方式 （Get、POST、OPTIONS、PUT、HEAD、DELETE、CONNECT、TRACE）
Status Code: 请求的返回状态码，如 200 代表成功

一般来说，请求头部和响应头部是匹配分析的。

- 请求头部的 Accept 要和响应头部的 Content-Type 匹配，否则会报错
- 跨域请求时，请求头部的 Origin 要匹配响应头部的 Access-Control-Allow-Origin，否则会报跨域错误
- 在使用缓存时，请求头部的 If-Modified-Since、If-None-Match 分别和响应头部的 Last-Modified、ETag 对应

1xx——指示信息，表示请求已接收，继续处理
2xx——成功，表示请求已被成功接收、理解、接受
3xx——重定向，要完成请求必须进行更进一步的操作
4xx——客户端错误，请求有语法错误或请求无法实现
5xx——服务器端错误，服务器未能实现合法的请求

200——表明该请求被成功地完成，所请求的资源发送回客户端
304——自从上次请求后，请求的网页未修改过，请客户端使用本地缓存
400——客户端请求有错（譬如可以是安全模块拦截）
401——请求未经授权
403——禁止访问（譬如可以是未登录时禁止）
404——资源未找到
500——服务器内部错误
503——服务不可用

- 常用的请求头
  Accept: 接收类型，表示浏览器支持的 MIME 类型 （对标服务端返回的 Content-Type）
  Accept-Encoding：浏览器支持的压缩类型,如 gzip 等,超出类型不能接收
  Content-Type：客户端发送出去实体内容的类型
  Cache-Control: 指定请求和响应遵循的缓存机制，如 no-cache
  If-Modified-Since：对应服务端的 Last-Modified，用来匹配看文件是否变动，只能精确到 1s 之内，http1.0 中
  Expires：缓存控制，在这个时间内不会请求，直接使用缓存，http1.0，而且是服务端时间
  Max-age：代表资源在本地缓存多少秒，有效时间内不会请求，而是使用缓存，http1.1 中
  If-None-Match：对应服务端的 ETag，用来匹配文件内容是否改变（非常精确），http1.1 中
  Cookie: 有 cookie 并且同域访问时会自动带上
  Connection: 当浏览器与服务器通信时对于长连接如何进行处理,如 keep-alive
  Host：请求的服务器 URL
  Origin：最初的请求是从哪里发起的（只会精确到端口）,Origin 比 Referer 更尊重隐私
  Referer：该页面的来源 URL(适用于所有类型的请求，会精确到详细页面地址，csrf 拦截常用到这个字段)
  User-Agent：用户客户端的一些必要信息，如 UA 头部等
- 常用的响应头
  Access-Control-Allow-Headers: 服务器端允许的请求 Headers
  Access-Control-Allow-Methods: 服务器端允许的请求方法
  Access-Control-Allow-Origin: 服务器端允许的请求 Origin 头部（譬如为\*）
  Content-Type：服务端返回的实体内容的类型
  Date：数据从服务器发送的时间
  Cache-Control：告诉浏览器或其他客户，什么环境可以安全的缓存文档
  Last-Modified：请求资源的最后修改时间
  Expires：应该在什么时候认为文档已经过期,从而不再缓存它
  Max-age：客户端的本地资源应该缓存多少秒，开启了 Cache-Control 后有效
  ETag：请求变量的实体标签的当前值
  Set-Cookie：设置和页面关联的 cookie，服务器通过这个头部把 cookie 传给客户端
  Keep-Alive：如果客户端有 keep-alive，服务端也会有响应（如 timeout=38）
  Server：服务器的一些相关信息

# http 的缓存： 强缓存与弱缓存

强缓存（200 from cache）时 Cache-Control/Max-Age，浏览器如果判断本地缓存未过期，就直接使用，无需发起 http 请求
协商缓存（304）时（http1.1）If-None-Match/E-tag（http1.0）If-Modified-Since/Last-Modified，浏览器会向服务端发起 http 请求，然后服务端告诉浏览器文件未改变，让浏览器使用本地缓存

# 解析页面流程

1. 解析 HTML，构建 DOM 树
2. 解析 CSS，生成 CSSOM
3. 解析 Javascript 脚本。由于 Javascript 脚本可以操作 DOM 节点和 CSS 规则，因此该过程中会等待 JavaScript 运行完成才继续解析 HTML
4. 合并 DOM 树和 CSSOM，生成 render 树
5. 布局 render 树（Layout/reflow），负责各元素尺寸、位置的计算。通过解析之后，渲染器进程知道每个节点的结构和样式，但如果需要渲染页面，浏览器还需要进行布局，像 header 或 display:none 的元素，它们会存在 DOM 节点树中，但不会被添加到渲染树里
6. 分层，我们可以在 devtools layers 里面看到具体的分层情况。拥有层叠上下文属性的元素会被提升为单独的一层、transform
7. 绘制 render 树（paint），绘制页面像素信息
8. 浏览器会将各层的信息发送给合成线程，合成器线程将每个图层栅格化，然后将每个图块发送给光栅线程。光栅线程栅格化每个图块，并将它们存储在 GPU 内存中。合成器线程通过 IPC 提交给浏览器进程，这些合成器帧被发送到 GPU 进程处理，并显示在屏幕上。

# 简单层与复合层

# loaded 和 domcontentloaded

DOMContentLoaded 事件触发时，仅当 DOM 加载完成，不包括样式表，图片(譬如如果有 async 加载的脚本就不一定完成)
load 事件触发时，页面上所有的 DOM，样式表，脚本，图片都已经加载完成了
