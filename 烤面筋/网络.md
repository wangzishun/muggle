- [跨域](#跨域)
- [三次握手](#三次握手)
- [四次挥手](#四次挥手)
- [慢启动](#慢启动)
- [TCP 滑动窗口, TCP 必须按序处理数据](#tcp-滑动窗口-tcp-必须按序处理数据)
- [http/1.0](#http10)
- [http/1.x](#http1x)
- [http/2](#http2)
- [http/3, QUIC 协议基于传输层 UDP 协议](#http3-quic-协议基于传输层-udp-协议)
- [UDP 可靠传输](#udp-可靠传输)
- [socket.io 是怎么通信的？](#socketio-是怎么通信的)

# 跨域

跨域是浏览器的安全策略，协议+域名+端口号一致就是同源策略，否则就是跨域。跨域的时候不能访问 cookie/localStorage/indexDB/dom， 但是 img/link/script/style/iframe 可以进行跨域加载资源。

ajax 请求当涉及到跨域的时候有简单请求和复杂请求。

简单请求是，请求方法：GET、POST、HEAD，限定的几个请求头 Accept、Accept-Language、Content-Language、Content-Type、DPR、Downlink、Save-Data、Viewport-Width、Width、Content-Type(text/plain、multipart/form-data、application/x-www-form-urlencoded)

除了简单请求其余的都是复杂请求，浏览器里面可以看到复杂请求会先发一个 OPTIONS 预检请求，通过了预检才会发起真正的请求。

对于简单请求，可以设置 Access-Control-Allow-Origin: \*， 当然也可以限定具体的源。

对于复杂请求来说需要设置允许的请求方式和请求头，还有一个预检请求的有效期，单位为秒
Access-Control-Request-Method: POST
Access-Control-Request-Headers: X-CUSTOMER-HEADER, Content-Type
Access-Control-Max-Age

另外如果需要跨域携带 cookie 的话，服务器设置 Access-Control-Allow-Credentials: true，而且 Origin 不能是\*，必须是具体的源。
前端 xhr 需要设置 withCredentials: true
fetch 不仅需要设置 mode: 'cors'，还需要需要设置 credentials: 'include' \*same-origin, omit

- jsonp 利用 script 标签没有跨域限制的漏洞，可以加载动态脚本。后端服务主要是从请求中拿到回调函数的名字，然后把数据包装成函数调用再返回，浏览器会自己执行这个脚本
- websocket 不是 http 协议，可以跨域
- 跨域是浏览器层面的，所以可以通过服务层进行代理，不管是 nginx 还是 node 都可以避免跨域

# 三次握手

保证 Client/Server 双方都能确认自己的接收和发送能力没问题的最小次数. 三次握手才可以阻止重复历史连接的初始化（主要原因）, 才可以同步双方的初始序列号, 才可以避免资源浪费

第一次握手：建立连接时, 客户端发送 SYN 包（seq=x）到服务器, 并进入 SYN_SENT 状态, 等待服务器确认. （SYN：同步序列编号, Synchronize Sequence Numbers）；
第二次握手：服务器收到 SYN 包, 必须确认客户的 SYN（ack=x+1）, 同时自己也发送一个 SYN 包（seq=y）, 即 SYN + ACK 包, 此时服务器进入 SYN_RECEVED 状态；
第三次握手：客户端收到服务器的 SYN + ACK 包, 向服务器发送确认包 ACK（ack=y+1）, 此包发送完毕, 客户端和服务器端进入 ESTABLISHED（TCP 连接成功）状态, 完成三次握手.

为了保证后续的握手是为了应答上一个握手, 每次握手都会带一个标识 seq, 后续的 ACK 都会对这个 seq 进行加一来进行确认.

第一次握手：这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的.
第二次握手：这样客户端就能得出结论：服务端的接收、发送能力, 客户端的接收、发送能力是正常的. 服务器还需要确认客户端的接收能力是否正常.
第三次握手：这样服务端就能得出结论：客户端的接收、发送能力正常, 服务器自己的发送、接收能力也正常.

三次是最少的安全次数, 两次不安全, 四次浪费资源

- A、B 机器正常连接后, B 机器突然重启, 问 A 此时处于 TCP 什么状态?

# 四次挥手

第一次挥手：客户端向服务器发送 FIN 标志, 序列号 seq=x, 用于关闭客户端到服务器的数据传送, 进入 FIN_WAIT_1 状态。这表示客户端告诉服务器我已经没有数据要发给你了。
第二次挥手：服务器接收到 FIN 标志后, 发送一个 ack=x+1, 告知客户端它已经接收到了关闭请求, 进入 CLOSE_WAIT 状态。Clinet 接收到回应后进入 FIN_WAIT_2 状态。但是这期间可能有剩余数据需要发送
第三次挥手：服务器发送 FIN 标志,序列号 seq=y, 用于关闭服务器到客户端的数据传送, 进入 LAST_ACK 状态。这表示服务器告诉客户端我也没有数据要发送给你了。
第四次挥手：客户端接收到 FIN 标志后, 发送一个 ack=y+1, 告知服务器它已经接收到请求关闭, 进入 TIME_WAIT 状态。
服务器接收到回应进入 CLOSED 状态。等待 2MSL 两个最大生命周期后, 客户端依然没有收到其他回复, 则也进入 CLOSED。

关闭连接时, 当客户端端发出 FIN 报文段时, 只是表示客户端端告诉服务器端数据已经发送完毕了。当服务器端收到 FIN 报文并返回 ACK 报文段, 表示它已经知道客户端端没有数据发送了, 但是服务器端还是可以发送数据到客户端端的, 所以服务器很可能并不会立即关闭 SOCKET, 直到服务器端把数据也发送完毕。当服务器端也发送了 FIN 报文段时, 这个时候就表示服务器端也没有数据要发送了, 就会告诉客户端端, 我也没有数据要发送了, 之后彼此就会愉快的中断这次 TCP 连接。

- 为什么要等待 2MSL？
  MSL：报文段最大生存时间, 它是任何报文段被丢弃前在网络内的最长时间。
  第一点：保证 TCP 协议的全双工连接能够可靠关闭：由于 IP 协议的不可靠性或者是其它网络原因, 导致了服务器端没有收到客户端端的 ACK 报文, 那么服务器端就会在超时之后重新发送 FIN, 如果此时客户端端的连接已经关闭处于 CLOESD 状态, 那么重发的 FIN 就找不到对应的连接了, 从而导致连接错乱, 所以, 客户端端发送完最后的 ACK 不能直接进入 CLOSED 状态, 而要保持 TIME_WAIT, 当再次收到 FIN 的收, 能够保证对方收到 ACK, 最后正确关闭连接。
  第二点：保证这次连接的重复数据段从网络中消失,如果客户端端发送最后的 ACK 直接进入 CLOSED 状态, 然后又再向服务器端发起一个新连接, 这时不能保证新连接的与刚关闭的连接的端口号是不同的, 也就是新连接和老连接的端口号可能一样了, 那么就可能出现问题：如果前一次的连接某些数据滞留在网络中, 这些延迟数据在建立新连接后到达客户端端, 由于新老连接的端口号和 IP 都一样, TCP 协议就认为延迟数据是属于新连接的, 新连接就会接收到脏数据, 这样就会导致数据包混乱。

# 慢启动

建立连接后, 会先只发 1 条, 然后发 2 条, 接着再发 4 条, 逐步增加. 这个过程叫 “慢启动”. 这个 1、2、4 递增的数量被称之为 拥塞窗口 cwnd
当到达慢启动门限 ssthreshold 时, 会变成每次都增加 1 条. 这个过程叫拥塞避免过程.

# TCP 滑动窗口, TCP 必须按序处理数据

- TCP 发送出去的数据, 都是需要按序确认的, 只有在数据都被按顺序确认完后, 发送窗口才会往前滑动. 客户端发送了第 5 ～ 9 的数据, 但是第 5 字节的 ACK 确认报文在网络中丢失了, 那么即使客户端收到第 6 ～ 9 字节的 ACK 确认报文, 发送窗口也不会往前移动. 此时的第 5 字节相当于“队头”, 因为没有收到“队头”的 ACK 确认报文, 导致发送窗口无法往前移动, 此时发送方就无法继续发送后面的数据, 这就是发送窗口的队头阻塞问题
- 当接收窗口收到有序数据时, 接收窗口才能往前滑动, 然后那些已经接收并且被确认的「有序」数据就可以被应用层读取. 接收方收到的数据范围必须在接收窗口范围内, 如果收到超过接收窗口范围的数据, 就会丢弃该数据, 比如接收窗口的范围是 32 ～ 51 , 如果收到第 52 以上数据都会被丢弃

# http/1.0

- 每次请求都会进行 TCP 三次握手四次挥手
- 文本格式床书, 串行的文件传输
- 服务器的连接数过多, 需要等待连接释放后才能访问服务器

# http/1.x

- 并发连接有限, 谷歌浏览器最大并发连接数是 6 个, 而且每一个连接都要经过 TCP 和 TLS 握手耗时, 以及 TCP 慢启动过程给流量带来的影响
- 队头阻塞问题, 同一连接只能在完成一个 HTTP 事务(请求和响应)后, 才能处理下一个事务
- HTTP 头部体积大, HTTP 协议是无状态的, 每一个请求都得携带 HTTP 头部, 特别是对于有携带 cookie 的头部, 而 cookie 的大小通常很大
- 引入了持久连接, 默认允许 Connection: keep-alive, TCP 连接默认不关闭, 可以被多个请求复用, 但是服务器需要按次序进行处理, 造成队头阻塞问题

- 雪碧图、base64 图片减少网络请求
- 资源分散到不用的域名, 提高并发连接的上限

# http/2

基于传输层 TCP 协议. 有帧(frame)和流(stream)的概念,

- 头部压缩, HPACK 算法, 客户端和服务端都各自维护字典, 通过索引号表示重复的字段, 再用 Huffman 编码压缩数据

  - 静态表, 61 种高频出现在头部的字符串
  - 动态表, 必须同一个连接上, 重复传输完全相同的 HTTP 头部时会更新. 比如第一次发送时头部有一个 TEST 字段数据有上百个字节, 经过 Huffman 编码发送出去后, 客户端和服务器双方都会更新自己的动态表, 添加一个新的 Index 号 62. 那么在下一次发送的时候, 就不用重复发这个字段的数据, 只要发送索引号就可以, 因为双方都可以根据自己的动态表获取到字段的数据. 动态表越大, 占用的内存也就越大, 服务器都会提供类似 http2_max_requests 的配置, 用于限制一个连接上能够传输的请求数量, 避免动态表无限增大, 请求数量到达上限后, 就会关闭连接来释放内存.
  - Huffman 编码

- 使用二进制格式进行传输, 在应用层和传输层之间加了一个二进制分帧层, 将报文分割成 frame 帧, 并采用二进制格式编码

- 多路复用, 相同域名下的请求可以通过同一个 TCP 连接并发完成, 多个流 Stream 复用一条 TCP 连接, 达到并发的效果. 每一个 TCP 连接中承载了多个流, 每一个流都有一个独一无二的标识和优先级, 而流就是由二进制帧组成的. 二进制帧的头部信息会标识自己属于哪一个流, 所以这些帧是可以交错传输, 然后在接收端通过帧头的信息组装成完整的数据
  - 1 个 TCP 连接包含一个或者多个 Stream; Stream 里可以包含多个 Message, Message 对应请求或响应; Message 里包含多个 Frame, 以二进制压缩格式存放请求头和请求体;
  - 不同 Stream 的帧是可以乱序发送的, 因为每个帧的头部会携带 Stream ID 信息, 所以接收端可以通过 Stream ID 有序组装成 HTTP 消息, 而同一 Stream 内部的帧必须是严格有序的.
  - 单个 TCP 通道没有解决 TCP 层面的阻塞问题, TCP 是字节流协议, 这意味着多个 Stream 共用同一个 TCP 滑动窗口, 那么当发生数据丢失, 滑动窗口是无法往前移动的, 此时就会阻塞住所有的 HTTP 请求, 这属于 TCP 层队头阻塞.
- 服务器推送, 可以对客户端的一个请求发送多个响应

# http/3, QUIC 协议基于传输层 UDP 协议

- 连接迁移
- 无队头阻塞 QUIC 也借鉴 HTTP/2 里的 Stream 的概念, 在一条 QUIC 连接上可以并发发送多个 HTTP 请求 (Stream). 但是 QUIC 给每一个 Stream 都分配了一个独立的滑动窗口, 这样使得一个连接上的多个 Stream 之间没有依赖关系, 都是相互独立的, 各自控制的滑动窗口. 假如 Stream2 丢了一个 UDP 包, 也只会影响 Stream2 的处理, 不会影响其他 Stream, 与 HTTP/2 不同, HTTP/2 只要某个流中的数据包丢失了, 其他流也会因此受影响.
- 自定义的拥塞机制
- 前向安全和前向纠错

# UDP 可靠传输

1. 接收方收到 UDP 之后回复个确认包,
2. 发送方收不到确认包就要重新发送,

每个包有递增的序号, 接收方发现中间丢了包就要发重传请求, 当网络太差时候频繁丢包, 防止越丢包越重传的恶性循环, 要有个发送窗口的限制, 发送窗口的大小根据网络传输情况调整, 调整算法要有一定自适应性.
TCP 可靠传输的特性（序列号、确认应答、超时重传、流量控制、拥塞控制）在应用层实现一遍.

# socket.io 是怎么通信的？

是基于 WebSocket 的 C-S 实时通信库。engine.io，这个库实现了跨平台的双向通信，使用了 WebSocket 和 XMLHttprequest（或 JSONP） 封装了一套自己的 Socket 协议（暂时叫 EIO Socket），在低版本浏览器里面使用长轮询替代 WebSocket。一个完整的 EIO Socket 包括多个 XHR 和 WebSocket 连接.EIO Socket 通过一个 XHR (XMLHttprequest) 握手。前端发送一个 XHR，告诉服务端我要开始 XHR 长轮询了。后端返回的数据里面包括一个 open 标志(数字 0 表示), 以及一个 sid 和 upgrades 字段。sid 是本次 EIO Socket 的会话 ID，因为一次 EIO Socket 包含了多个请求，而后端又会同时连接多个 EIO Socket，sid 的作用就相当于 SESSION ID。另一个字段 upgrades，表示可以把连接方式从长轮询升级到 WebSocket.

WebSocket 是基于 TCP/IP 协议，的双向通信协议，因为不是 http 协议，所以不受同源限制。相对于传统的 Ajax 轮询。WebSocket 协议优势如下、：互相沟通的 Header 非常小，只有 2Bytes 左右。服务器不再被动接收到浏览器的请求之后才返回数据，而是在有新数据时就主动推送给浏览器。WebSocket 协议能更好的节省服务器资源和带宽，并且能够更实时地进行通讯
