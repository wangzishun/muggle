# API 代码生成服务(服务端生成结合 CLI 更新工具)

# 说一下这个项目？

这个项目是基于 openapi-generatoer 进行的二次开发，我先说一下 openapi-generatoer，他能够将 openapi 或者 swagger 文档转成代码文件。于是我在他的基础上，实现了服务端生成代码文件，并且结合 cli 工具去更新本地仓库。其实像代码生成这样的工具市面上已经有很多了，比如 apifox 还有一些 vscode 插件都可以生成代码。其实市面上的工具我用过好几款，发现他们有一个共同的问题，就是需要人工去操作生成代码，这样其实有很多问题，一个是我们程序员都比较懒嘛，在一个是如果生成的代码文件都放到项目里，merge 合并的时候很容易产生冲突，这个问题其实很痛苦，只能重新生成，体验非常不好。所以我的目标就是这个过程自动化，让代码生成的过程不需要人工干预。

# 工作流程是什么样的？

项目的核心思路是由 node 端去生成代码文件，开发者在项目中通过 cli 工具来接受文件的更新。
项目的必要条件是，后端服务使用 swagger 或者是 openapi 这些社区最流行文档格式，没必要自己去重新实现一套文档解析的工具。

我这个服务需要与集团现有的云平台进行集成，因为当后端更新代码的时候，我得知道是哪个集群的那台 pod 机器触发了部署动作，我要等他部署完成后通知我这边的 node 服务，触发代码文件的生成动作，生成后需要经过一个简单的单元测试，再将文件推送到 git 仓库和 npm 仓库，到这一步代码生成的流程就结束了。node 端除了生成，还通过 socket.io/server 维护了一个 Websocket。生成完成后会在 socket 中进行广播通知，再之后就是 cli 工具的任务了。

cli 工具需要在本地仓库启动 dev 命令的时候一起运行, 运行的时候会先去读取 packagejson，筛选出需要更新的依赖包，然后通过 socket.io/client 加入到房间中进行依赖版本的对比任务，如果发现本地有依赖包需要升级，那么就会调用 npm/yarn/pnpm 来升级这个包。

这个时候其实还有一个问题，对于某个后端服务来说，他的集群中有非常多的 pod 机器，而我这边会为每个 pod 机器都生成一份代码包，换句话来说，就是每台机器对应了一个需求，那么作为前端开发者来说我肯定期望能直接拿到他正在开发的需求对应的代码包，所以要想使用体验比较好的话，我得满足他这个需求。这个问题我解决方案其实不够优雅，（不知道您有没有用过 npm 的 dist-tag，他其实像是一个指针，可以指向任意版本，比如说 npm install react，其实是安装了 react 的 latest tag 指向的版本，dist-tag 可以自己定义并且可以自由指定版本，比如说有 0-9 十个版本，我可以让 latest tag 指向 version0 也可以让他指向 version9，除了 latest 这个默认的 tag，还可以自己定义其他的, npm publish --tag test），首先是 pod 机器都有一个自己的内网 ip，咱也别管他是 172.20 开头的还是 192.168，我利用这个 ip 给 git 仓库建立分支，只要是这个 ip 生成的文件我都会推送到这个分支上，同样的 npm 仓库也会有属于这个 ip 的 dist-tag，只要是这个 ip 生成的代码包在发布之后我都会更新他的 dist-tag。这样我就实现了以 pod 机器 ip 纬度进行管理的代码文件。然后我还需要一个配置文件，开发者得告诉我他需要哪台机器的代码包，我就会帮他下载对应的版本。

# 遇到了什么问题？

这个项目是我周末脑袋瓜一热搞出来的，问题还是很多的。先说一个我遇到的最傻的一个技术问题吧，因为傻印象才深嘛，在 node 端生成代码需要运行 shell 命令嘛，但是在运行工具的过程中他偶尔会报错，这种偶现的问题就特别难默认，我排查了很久才发现问题，因为我 shell 脚本用的是 exec 去执行的，exec 限制了缓冲区，工具执行过程中会输出大量的日志，导致缓冲区爆掉了。然后我换成 child.spawn 就好了。因为经验不足产生了这个特别傻这个问题。

首先是更新的方式，基本思路是通过 node 服务生成文件，cli 更新文件，但是具体怎么更新也是一个大问题，比如我可以将每个后端服务都单独生成一个依赖包，直接 npm install yarn add，这样代码冲突限制在了 packagejson 里，但是依赖包的方式又会引入版本管理的概念；另外一种是直接下载文件到项目目录中，这种方式为了避免代码冲突问题，只能是搞一个临时文件夹，类似于 umi 或者是 webpack 的缓存文件夹，这种方式的升级版是 git submodule。总的来说我还没有想到一个超级完美的方案，目前是只实现了 npm 包的方式进行管理，因为简单嘛。

后期的问题也很多，都是还没有解决的问题。
还有一个重复生成的问题，同一个后端服务可能同时部署了好几个版本，意味着需要对所有的版本都生成一遍，我目前是加了一个队列进行控制，因为是单机单实例服务所以不会有并发问题，但是如果是多实例的场景就完蛋了，如果之后需要加机器的话，还需要再设计一下。队列的设计：以后端服务的维度来划分队列，每个服务都有一条自己的队列，云平台机器部署成功后会请求生成代码文件，根据这个请求会拿到 pod 机器的 ip、仓库和版本号，我会把它当做一个事件加入队列，加入之前会去通过 git-tag 来确定这个仓库的版本号是否已经生成过，或者是不是在队列中，避免重复生成。

生成的文件体积，开源工具的默认模版体积比自己写接口要大百分之十多一点，比如两千个接口自己写可能需要 100k，生成的代码就需要 110k，120k 的样子，差距还是挺大的，所以需要自己定制模版。
现在后端服务的配置文件都是我写在代码里，所以还需要设计一个服务注册的机制。node 端在生成代码后会推送到 git 和 npm 上，因为是大量的文件读取所以生成性能上很差，当然现在用的还比较少。
